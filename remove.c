/**
 * Copyright (c) 2014 - 2015 Tolga Cakir <tolga@cevel.net>
 *
 * This source file is part of Elgato Game Capture HD Linux driver and is
 * distributed under the MIT License. For more information, see LICENSE file.
 */

#include "commands.h"

void remove_elgato() {
	// state change - output null
	scmd(SCMD_STATE_CHANGE, 0x00, 0x0004);

	// usually, this is done by a seperate thread, which runs in parallel.
	// I'm just quickly hacking a way around it, to test some stuff. Taking
	// a big, random number, which is slightly based on the USB traffic logs
	// I'm working with. Receive empty data, after setting state change to
	// null transfer.
	for (int i = 0; i < 5000; i++) {
		receive_data();
	}

	// we probably need some sleeps here and receive null output, to give
	// the Elgato enough time to gracefully reset. Else, the next scmd()
	// command seems to be ignored and we're leaving the device in an
	// undefined state.
	read_config(0xbc, 0x0800, 0x2008, 2);

	for (int i = 0; i < 50; i++) {
		receive_data();
	}

	read_config(0xbc, 0x0900, 0x0074, 2);

	for (int i = 0; i < 50; i++) {
		receive_data();
	}

	read_config(0xbc, 0x0900, 0x01b0, 2);

	for (int i = 0; i < 50; i++) {
		receive_data();
	}

	read_config(0xbc, 0x0800, 0x2008, 2);

	for (int i = 0; i < 50; i++) {
		receive_data();
	}

	read_config(0xbc, 0x0800, 0x2008, 2);


	for (int i = 0; i < 50; i++) {
		receive_data();
	}

	write_config2(0xbc, 0x0900, 0x0074, 0x00, 0x04);

	for (int i = 0; i < 50; i++) {
		receive_data();
	}

	write_config2(0xbc, 0x0900, 0x01b0, 0x00, 0x00);

	for (int i = 0; i < 50; i++) {
		receive_data();
	}

	// state change - stop encoding
	scmd(SCMD_STATE_CHANGE, 0x00, 0x0001);

	for (int i = 0; i < 5; i++) {
		receive_data();
	}

	read_config(0xbc, 0x0800, 0x2008, 2);
	read_config(0xbc, 0x0900, 0x0074, 2);
	read_config(0xbc, 0x0900, 0x01b0, 2);
	read_config(0xbc, 0x0800, 0x2008, 2);
	read_config(0xbc, 0x0800, 0x2008, 2);

	write_config2(0xbc, 0x0900, 0x0074, 0x00, 0x04);
	write_config2(0xbc, 0x0900, 0x01b0, 0x00, 0x00);
	write_config2(0xbd, 0x0000, 0x4400, 0x06, 0x86);
	write_config2(0xbc, 0x0900, 0x0014, 0x03, 0x1e);

	read_config(0xbc, 0x0900, 0x001c, 2);

	write_config3(0xbd, 0x0000, 0x3300, 0x89, 0x89, 0xf8);
	write_config2(0xbc, 0x0900, 0x0014, 0x03, 0x1e);

	read_config(0xbc, 0x0900, 0x001c, 2);

	write_config2(0xbc, 0x0900, 0x0014, 0x03, 0x1e);

	read_config(0xbc, 0x0900, 0x001c, 2);
	read_config(0xbd, 0x0000, 0x3300, 1);

	write_config2(0xbd, 0x0000, 0x4400, 0x03, 0x2f);
	write_config2(0xbc, 0x0900, 0x0014, 0x03, 0x1e);

	read_config(0xbc, 0x0900, 0x001c, 2);

	write_config2(0xbc, 0x0900, 0x0000, 0x00, 0x00);

	read_config(0xbc, 0x0900, 0x0014, 2);
	read_config(0xbc, 0x0800, 0x2008, 2);

	write_config8(0xbc, 0x0001, 0x1a08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00);

	write_config6(0xb8, 0x0000, 0x0000, 0x00, 0x00, 0x04, 0xa0, 0x00, 0x00);

	write_config2(0xbc, 0x0900, 0x0014, 0x03, 0x16);

	read_config(0xbc, 0x0900, 0x001c, 2);

	write_config2(0xbc, 0x0900, 0x0014, 0x03, 0x06);

	read_config(0xbc, 0x0900, 0x001c, 2);

	write_config2(0xbc, 0x0900, 0x0014, 0x02, 0x06);

	read_config(0xbc, 0x0900, 0x001c, 2);

	write_config2(0xbc, 0x0900, 0x0014, 0x00, 0x06);

	read_config(0xbc, 0x0900, 0x001c, 2);

	write_config5(0xbd, 0x0000, 0x3300, 0xab, 0xa9, 0x0f, 0xa4, 0x55);
	write_config2(0xbc, 0x0900, 0x0014, 0x00, 0x06);

	read_config(0xbc, 0x0900, 0x001c, 2);
	read_config(0xbd, 0x0000, 0x3300, 3);

	write_config2(0xbc, 0x0900, 0x0014, 0x00, 0x06);
	write_config2(0xbc, 0x0900, 0x0018, 0x00, 0x08);

	read_config(0xbc, 0x0900, 0x0014, 2);
	read_config(0xbc, 0x0900, 0x0018, 2);

	write_config5(0xbd, 0x0000, 0x3300, 0xab, 0xa9, 0x0f, 0xa4, 0x55);
	write_config2(0xbc, 0x0900, 0x0014, 0x00, 0x06);

	read_config(0xbc, 0x0900, 0x001c, 2);
	read_config(0xbd, 0x0000, 0x3300, 3);

	write_config2(0xbc, 0x0900, 0x0014, 0x00, 0x06);
	write_config2(0xbc, 0x0900, 0x0018, 0x00, 0x08);

	read_config(0xbc, 0x0900, 0x0014, 2);
	read_config(0xbc, 0x0900, 0x0018, 2);
	read_config(0xbc, 0x0800, 0x2008, 2);

	write_config6(0xb8, 0x0000, 0x0000, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00);

	read_config(0xbc, 0x0800, 0x2008, 2);
	read_config(0xbc, 0x0900, 0x0074, 2);
	read_config(0xbc, 0x0900, 0x01b0, 2);
	read_config(0xbc, 0x0800, 0x2008, 2);
	read_config(0xbc, 0x0800, 0x2008, 2);

	write_config2(0xbc, 0x0900, 0x0074, 0x00, 0x04);
	write_config2(0xbc, 0x0900, 0x01b0, 0x00, 0x00);

	read_config(0xbc, 0x0800, 0x2008, 2);

	write_config6(0xb8, 0x0000, 0x0000, 0x00, 0x00, 0x02, 0x01, 0x00, 0x00);

	read_config(0xbc, 0x0800, 0x2008, 2);
	read_config(0xbc, 0x0900, 0x0074, 2);
	read_config(0xbc, 0x0900, 0x01b0, 2);
	read_config(0xbc, 0x0800, 0x2008, 2);
	read_config(0xbc, 0x0800, 0x2008, 2);

	write_config2(0xbc, 0x0900, 0x0074, 0x00, 0x04);
	write_config2(0xbc, 0x0900, 0x01b0, 0x00, 0x00);
}
